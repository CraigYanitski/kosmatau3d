<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scipy.interpolate._rgi &mdash; kosmatau3d 1.0.3 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/readthedocs-custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/documentation_options.js?v=baaebd52"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            kosmatau3d
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../properties.html">KOSMA-$\tau$ Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../voxel.html">Voxels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model.html">3D Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../comparison.html">Comparison to Observations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">Future Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/kosmatau3d.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../acknowledgements.html">Acknowledgements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">kosmatau3d</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">scipy.interpolate._rgi</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scipy.interpolate._rgi</h1><div class="highlight"><pre>
<span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;RegularGridInterpolator&#39;</span><span class="p">,</span> <span class="s1">&#39;interpn&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.interpnd</span> <span class="kn">import</span> <span class="n">_ndim_coords_from_arrays</span>
<span class="kn">from</span> <span class="nn">._cubic</span> <span class="kn">import</span> <span class="n">PchipInterpolator</span>
<span class="kn">from</span> <span class="nn">._rgi_cython</span> <span class="kn">import</span> <span class="n">evaluate_linear_2d</span><span class="p">,</span> <span class="n">find_indices</span>
<span class="kn">from</span> <span class="nn">._bsplines</span> <span class="kn">import</span> <span class="n">make_interp_spline</span>
<span class="kn">from</span> <span class="nn">._fitpack2</span> <span class="kn">import</span> <span class="n">RectBivariateSpline</span>


<span class="k">def</span> <span class="nf">_check_points</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
    <span class="n">descending_dimensions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="c1"># early make points float</span>
        <span class="c1"># see https://github.com/scipy/scipy/pull/17230</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># input is descending, so make it ascending</span>
                <span class="n">descending_dimensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The points in dimension </span><span class="si">%d</span><span class="s2"> must be strictly &quot;</span>
                    <span class="s2">&quot;ascending or descending&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">descending_dimensions</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_dimensionality</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">%d</span><span class="s2"> point arrays, but values has </span><span class="si">%d</span><span class="s2"> &quot;</span>
                         <span class="s2">&quot;dimensions&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The points in dimension </span><span class="si">%d</span><span class="s2"> must be &quot;</span>
                             <span class="s2">&quot;1-dimensional&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">%d</span><span class="s2"> points and </span><span class="si">%d</span><span class="s2"> values in &quot;</span>
                             <span class="s2">&quot;dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span>


<div class="viewcode-block" id="RegularGridInterpolator">
<a class="viewcode-back" href="../../../_autosummary/generated/scipy.interpolate.RegularGridInterpolator.html#scipy.interpolate.RegularGridInterpolator">[docs]</a>
<span class="k">class</span> <span class="nc">RegularGridInterpolator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolation on a regular or rectilinear grid in arbitrary dimensions.</span>

<span class="sd">    The data must be defined on a rectilinear grid; that is, a rectangular</span>
<span class="sd">    grid with even or uneven spacing. Linear, nearest-neighbor, spline</span>
<span class="sd">    interpolations are supported. After setting up the interpolator object,</span>
<span class="sd">    the interpolation method may be chosen at each evaluation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )</span>
<span class="sd">        The points defining the regular grid in n dimensions. The points in</span>
<span class="sd">        each dimension (i.e. every elements of the points tuple) must be</span>
<span class="sd">        strictly ascending or descending.</span>

<span class="sd">    values : array_like, shape (m1, ..., mn, ...)</span>
<span class="sd">        The data on the regular grid in n dimensions. Complex data can be</span>
<span class="sd">        acceptable.</span>

<span class="sd">    method : str, optional</span>
<span class="sd">        The method of interpolation to perform. Supported are &quot;linear&quot;,</span>
<span class="sd">        &quot;nearest&quot;, &quot;slinear&quot;, &quot;cubic&quot;, &quot;quintic&quot; and &quot;pchip&quot;. This</span>
<span class="sd">        parameter will become the default for the object&#39;s ``__call__``</span>
<span class="sd">        method. Default is &quot;linear&quot;.</span>

<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, when interpolated values are requested outside of the</span>
<span class="sd">        domain of the input data, a ValueError is raised.</span>
<span class="sd">        If False, then `fill_value` is used.</span>
<span class="sd">        Default is True.</span>

<span class="sd">    fill_value : float or None, optional</span>
<span class="sd">        The value to use for points outside of the interpolation domain.</span>
<span class="sd">        If None, values outside the domain are extrapolated.</span>
<span class="sd">        Default is ``np.nan``.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : tuple of ndarrays</span>
<span class="sd">        The points defining the regular grid in n dimensions.</span>
<span class="sd">        This tuple defines the full grid via</span>
<span class="sd">        ``np.meshgrid(*grid, indexing=&#39;ij&#39;)``</span>
<span class="sd">    values : ndarray</span>
<span class="sd">        Data values at the grid.</span>
<span class="sd">    method : str</span>
<span class="sd">        Interpolation method.</span>
<span class="sd">    fill_value : float or ``None``</span>
<span class="sd">        Use this value for out-of-bounds arguments to `__call__`.</span>
<span class="sd">    bounds_error : bool</span>
<span class="sd">        If ``True``, out-of-bounds argument raise a ``ValueError``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Contrary to `LinearNDInterpolator` and `NearestNDInterpolator`, this class</span>
<span class="sd">    avoids expensive triangulation of the input data by taking advantage of the</span>
<span class="sd">    regular grid structure.</span>

<span class="sd">    In other words, this class assumes that the data is defined on a</span>
<span class="sd">    *rectilinear* grid.</span>

<span class="sd">    .. versionadded:: 0.14</span>

<span class="sd">    The &#39;slinear&#39;(k=1), &#39;cubic&#39;(k=3), and &#39;quintic&#39;(k=5) methods are</span>
<span class="sd">    tensor-product spline interpolators, where `k` is the spline degree,</span>
<span class="sd">    If any dimension has fewer points than `k` + 1, an error will be raised.</span>

<span class="sd">    .. versionadded:: 1.9</span>

<span class="sd">    If the input data is such that dimensions have incommensurate</span>
<span class="sd">    units and differ by many orders of magnitude, the interpolant may have</span>
<span class="sd">    numerical artifacts. Consider rescaling the data before interpolating.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    **Evaluate a function on the points of a 3-D grid**</span>

<span class="sd">    As a first example, we evaluate a simple example function on the points of</span>
<span class="sd">    a 3-D grid:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import RegularGridInterpolator</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; def f(x, y, z):</span>
<span class="sd">    ...     return 2 * x**3 + 3 * y**2 - z</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(1, 4, 11)</span>
<span class="sd">    &gt;&gt;&gt; y = np.linspace(4, 7, 22)</span>
<span class="sd">    &gt;&gt;&gt; z = np.linspace(7, 9, 33)</span>
<span class="sd">    &gt;&gt;&gt; xg, yg ,zg = np.meshgrid(x, y, z, indexing=&#39;ij&#39;, sparse=True)</span>
<span class="sd">    &gt;&gt;&gt; data = f(xg, yg, zg)</span>

<span class="sd">    ``data`` is now a 3-D array with ``data[i, j, k] = f(x[i], y[j], z[k])``.</span>
<span class="sd">    Next, define an interpolating function from this data:</span>

<span class="sd">    &gt;&gt;&gt; interp = RegularGridInterpolator((x, y, z), data)</span>

<span class="sd">    Evaluate the interpolating function at the two points</span>
<span class="sd">    ``(x,y,z) = (2.1, 6.2, 8.3)`` and ``(3.3, 5.2, 7.1)``:</span>

<span class="sd">    &gt;&gt;&gt; pts = np.array([[2.1, 6.2, 8.3],</span>
<span class="sd">    ...                 [3.3, 5.2, 7.1]])</span>
<span class="sd">    &gt;&gt;&gt; interp(pts)</span>
<span class="sd">    array([ 125.80469388,  146.30069388])</span>

<span class="sd">    which is indeed a close approximation to</span>

<span class="sd">    &gt;&gt;&gt; f(2.1, 6.2, 8.3), f(3.3, 5.2, 7.1)</span>
<span class="sd">    (125.54200000000002, 145.894)</span>

<span class="sd">    **Interpolate and extrapolate a 2D dataset**</span>

<span class="sd">    As a second example, we interpolate and extrapolate a 2D data set:</span>

<span class="sd">    &gt;&gt;&gt; x, y = np.array([-2, 0, 4]), np.array([-2, 0, 2, 5])</span>
<span class="sd">    &gt;&gt;&gt; def ff(x, y):</span>
<span class="sd">    ...     return x**2 + y**2</span>

<span class="sd">    &gt;&gt;&gt; xg, yg = np.meshgrid(x, y, indexing=&#39;ij&#39;)</span>
<span class="sd">    &gt;&gt;&gt; data = ff(xg, yg)</span>
<span class="sd">    &gt;&gt;&gt; interp = RegularGridInterpolator((x, y), data,</span>
<span class="sd">    ...                                  bounds_error=False, fill_value=None)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax = fig.add_subplot(projection=&#39;3d&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(xg.ravel(), yg.ravel(), data.ravel(),</span>
<span class="sd">    ...            s=60, c=&#39;k&#39;, label=&#39;data&#39;)</span>

<span class="sd">    Evaluate and plot the interpolator on a finer grid</span>

<span class="sd">    &gt;&gt;&gt; xx = np.linspace(-4, 9, 31)</span>
<span class="sd">    &gt;&gt;&gt; yy = np.linspace(-4, 9, 31)</span>
<span class="sd">    &gt;&gt;&gt; X, Y = np.meshgrid(xx, yy, indexing=&#39;ij&#39;)</span>

<span class="sd">    &gt;&gt;&gt; # interpolator</span>
<span class="sd">    &gt;&gt;&gt; ax.plot_wireframe(X, Y, interp((X, Y)), rstride=3, cstride=3,</span>
<span class="sd">    ...                   alpha=0.4, color=&#39;m&#39;, label=&#39;linear interp&#39;)</span>

<span class="sd">    &gt;&gt;&gt; # ground truth</span>
<span class="sd">    &gt;&gt;&gt; ax.plot_wireframe(X, Y, ff(X, Y), rstride=3, cstride=3,</span>
<span class="sd">    ...                   alpha=0.4, label=&#39;ground truth&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Other examples are given</span>
<span class="sd">    :ref:`in the tutorial &lt;tutorial-interpolate_regular_grid_interpolator&gt;`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    NearestNDInterpolator : Nearest neighbor interpolation on *unstructured*</span>
<span class="sd">                            data in N dimensions</span>

<span class="sd">    LinearNDInterpolator : Piecewise linear interpolant on *unstructured* data</span>
<span class="sd">                           in N dimensions</span>

<span class="sd">    interpn : a convenience function which wraps `RegularGridInterpolator`</span>

<span class="sd">    scipy.ndimage.map_coordinates : interpolation on grids with equal spacing</span>
<span class="sd">                                    (suitable for e.g., N-D image resampling)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Python package *regulargrid* by Johannes Buchner, see</span>
<span class="sd">           https://pypi.python.org/pypi/regulargrid/</span>
<span class="sd">    .. [2] Wikipedia, &quot;Trilinear interpolation&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Trilinear_interpolation</span>
<span class="sd">    .. [3] Weiser, Alan, and Sergio E. Zarantonello. &quot;A note on piecewise linear</span>
<span class="sd">           and multilinear table interpolation in many dimensions.&quot; MATH.</span>
<span class="sd">           COMPUT. 50.181 (1988): 189-196.</span>
<span class="sd">           https://www.ams.org/journals/mcom/1988-50-181/S0025-5718-1988-0917826-0/S0025-5718-1988-0917826-0.pdf</span>
<span class="sd">           :doi:`10.1090/S0025-5718-1988-0917826-0`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this class is based on code originally programmed by Johannes Buchner,</span>
    <span class="c1"># see https://github.com/JohannesBuchner/regulargrid</span>

    <span class="n">_SPLINE_DEGREE_MAP</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;slinear&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;quintic&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;pchip&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
    <span class="n">_SPLINE_METHODS</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_SPLINE_DEGREE_MAP</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">_ALL_METHODS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_SPLINE_METHODS</span>

<div class="viewcode-block" id="RegularGridInterpolator.__init__">
<a class="viewcode-back" href="../../../_autosummary/generated/scipy.interpolate.RegularGridInterpolator.html#scipy.interpolate.RegularGridInterpolator.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ALL_METHODS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method &#39;</span><span class="si">%s</span><span class="s2">&#39; is not defined&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SPLINE_METHODS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_grid_dimensions</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="n">bounds_error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_descending_dimensions</span> <span class="o">=</span> <span class="n">_check_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dimensionality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_descending_dimensions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_descending_dimensions</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_check_dimensionality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">_check_dimensionality</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_check_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">):</span>
            <span class="c1"># allow reasonable duck-typed values</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;astype&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_check_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">fill_value_dtype</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;same_kind&#39;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill_value must be either &#39;None&#39; or &quot;</span>
                                 <span class="s2">&quot;of a type compatible with values&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolation at coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi : ndarray of shape (..., ndim)</span>
<span class="sd">            The coordinates to evaluate the interpolator at.</span>

<span class="sd">        method : str, optional</span>
<span class="sd">            The method of interpolation to perform. Supported are &quot;linear&quot;,</span>
<span class="sd">            &quot;nearest&quot;, &quot;slinear&quot;, &quot;cubic&quot;, &quot;quintic&quot; and &quot;pchip&quot;. Default is</span>
<span class="sd">            the method chosen when the interpolator was created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_x : ndarray, shape xi.shape[:-1] + values.shape[ndim:]</span>
<span class="sd">            Interpolated values at `xi`. See notes for behaviour when</span>
<span class="sd">            ``xi.ndim == 1``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the case that ``xi.ndim == 1`` a new axis is inserted into</span>
<span class="sd">        the 0 position of the returned array, values_x, so its shape is</span>
<span class="sd">        instead ``(1,) + values.shape[ndim:]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Here we define a nearest-neighbor interpolator of a simple function</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; x, y = np.array([0, 1, 2]), np.array([1, 3, 7])</span>
<span class="sd">        &gt;&gt;&gt; def f(x, y):</span>
<span class="sd">        ...     return x**2 + y**2</span>
<span class="sd">        &gt;&gt;&gt; data = f(*np.meshgrid(x, y, indexing=&#39;ij&#39;, sparse=True))</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import RegularGridInterpolator</span>
<span class="sd">        &gt;&gt;&gt; interp = RegularGridInterpolator((x, y), data, method=&#39;nearest&#39;)</span>

<span class="sd">        By construction, the interpolator uses the nearest-neighbor</span>
<span class="sd">        interpolation</span>

<span class="sd">        &gt;&gt;&gt; interp([[1.5, 1.3], [0.3, 4.5]])</span>
<span class="sd">        array([2., 9.])</span>

<span class="sd">        We can however evaluate the linear interpolant by overriding the</span>
<span class="sd">        `method` parameter</span>

<span class="sd">        &gt;&gt;&gt; interp([[1.5, 1.3], [0.3, 4.5]], method=&#39;linear&#39;)</span>
<span class="sd">        array([ 4.7, 24.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_method_changed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">!=</span> <span class="n">method</span>
        <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ALL_METHODS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method &#39;</span><span class="si">%s</span><span class="s2">&#39; is not defined&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="n">xi</span><span class="p">,</span> <span class="n">xi_shape</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">nans</span><span class="p">,</span> <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_xi</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_indices</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="c1"># a fast path</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">evaluate_linear_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                            <span class="n">indices</span><span class="p">,</span>
                                            <span class="n">norm_distances</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                                            <span class="n">out</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_linear</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_indices</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_nearest</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SPLINE_METHODS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_method_changed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_validate_grid_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_spline</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">out_of_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="c1"># f(nan) = nan, if any</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nans</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xi_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_prepare_xi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">):</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">_ndim_coords_from_arrays</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The requested sample points xi have dimension &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> but this &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;RegularGridInterpolator has dimension </span><span class="si">{</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">xi_shape</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xi_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># find nans in input</span>
        <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">),</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of the requested xi is out of bounds &quot;</span>
                                     <span class="s2">&quot;in dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_out_of_bounds</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xi_shape</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">nans</span><span class="p">,</span> <span class="n">out_of_bounds</span>

    <span class="k">def</span> <span class="nf">_evaluate_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">):</span>
        <span class="c1"># slice for broadcasting over trailing dimensions in self.values</span>
        <span class="n">vslice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

        <span class="c1"># Compute shifting up front before zipping everything together</span>
        <span class="n">shift_norm_distances</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">yi</span> <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="n">norm_distances</span><span class="p">]</span>
        <span class="n">shift_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="c1"># The formula for linear interpolation in 2d takes the form:</span>
        <span class="c1"># values = self.values[(i0, i1)] * (1 - y0) * (1 - y1) + \</span>
        <span class="c1">#          self.values[(i0, i1 + 1)] * (1 - y0) * y1 + \</span>
        <span class="c1">#          self.values[(i0 + 1, i1)] * y0 * (1 - y1) + \</span>
        <span class="c1">#          self.values[(i0 + 1, i1 + 1)] * y0 * y1</span>
        <span class="c1"># We pair i with 1 - yi (zipped1) and i + 1 with yi (zipped2)</span>
        <span class="n">zipped1</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">shift_norm_distances</span><span class="p">)</span>
        <span class="n">zipped2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shift_indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">)</span>

        <span class="c1"># Take all products of zipped1 and zipped2 and iterate over them</span>
        <span class="c1"># to get the terms in the above formula. This corresponds to iterating</span>
        <span class="c1"># over the vertices of a hypercube.</span>
        <span class="n">hypercube</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">zipped1</span><span class="p">,</span> <span class="n">zipped2</span><span class="p">))</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hypercube</span><span class="p">:</span>
            <span class="n">edge_indices</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">w</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">])</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">vslice</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="n">term</span>   <span class="c1"># cannot use += because broadcasting</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_evaluate_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">):</span>
        <span class="n">idx_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yi</span> <span class="o">&lt;=</span> <span class="mf">.5</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">norm_distances</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_res</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_validate_grid_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SPLINE_DEGREE_MAP</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> points in dimension </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">,&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; but method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> requires at least &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> points per dimension.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_evaluate_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="c1"># ensure xi is 2D list of points to evaluate (`m` is the number of</span>
        <span class="c1"># points and `n` is the number of interpolation dimensions,</span>
        <span class="c1"># ``n == len(self.grid)``.)</span>
        <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">xi</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Reorder the axes: n-dimensional process iterates over the</span>
        <span class="c1"># interpolation axes from the last axis downwards: E.g. for a 4D grid</span>
        <span class="c1"># the order of axes is 3, 2, 1, 0. Each 1D interpolation works along</span>
        <span class="c1"># the 0th axis of its argument array (for 1D routine it&#39;s its ``y``</span>
        <span class="c1"># array). Thus permute the interpolation axes of `values` *and keep</span>
        <span class="c1"># trailing dimensions trailing*.</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">axx</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[:</span><span class="n">n</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">axes</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pchip&#39;</span><span class="p">:</span>
            <span class="n">_eval_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_pchip</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_eval_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_spline_fit</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SPLINE_DEGREE_MAP</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>

        <span class="c1"># Non-stationary procedure: difficult to vectorize this part entirely</span>
        <span class="c1"># into numpy-level operations. Unfortunately this requires explicit</span>
        <span class="c1"># looping over each point in xi.</span>

        <span class="c1"># can at least vectorize the first pass across all points in the</span>
        <span class="c1"># last variable of xi.</span>
        <span class="n">last_dim</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">first_values</span> <span class="o">=</span> <span class="n">_eval_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">last_dim</span><span class="p">],</span>
                                  <span class="n">values</span><span class="p">,</span>
                                  <span class="n">xi</span><span class="p">[:,</span> <span class="n">last_dim</span><span class="p">],</span>
                                  <span class="n">k</span><span class="p">)</span>

        <span class="c1"># the rest of the dimensions have to be on a per point-in-xi basis</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">:])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="c1"># Main process: Apply 1D interpolate in each dimension</span>
            <span class="c1"># sequentially, starting with the last dimension.</span>
            <span class="c1"># These are then &quot;folded&quot; into the next dimension in-place.</span>
            <span class="n">folded_values</span> <span class="o">=</span> <span class="n">first_values</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">last_dim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Interpolate for each 1D from the last dimensions.</span>
                <span class="c1"># This collapses each 1D sequence into a scalar.</span>
                <span class="n">folded_values</span> <span class="o">=</span> <span class="n">_eval_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                           <span class="n">folded_values</span><span class="p">,</span>
                                           <span class="n">xi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                           <span class="n">k</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">folded_values</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_do_spline_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">local_interp</span> <span class="o">=</span> <span class="n">make_interp_spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">local_interp</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_do_pchip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">local_interp</span> <span class="o">=</span> <span class="n">PchipInterpolator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">local_interp</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_find_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">find_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_out_of_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">):</span>
        <span class="c1"># check for out of bounds xi</span>
        <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># iterate through dimensions</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="n">out_of_bounds</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out_of_bounds</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out_of_bounds</span></div>



<div class="viewcode-block" id="interpn">
<a class="viewcode-back" href="../../../_autosummary/generated/scipy.interpolate.interpn.html#scipy.interpolate.interpn">[docs]</a>
<span class="k">def</span> <span class="nf">interpn</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional interpolation on regular or rectilinear grids.</span>

<span class="sd">    Strictly speaking, not all regular grids are supported - this function</span>
<span class="sd">    works on *rectilinear* grids, that is, a rectangular grid with even or</span>
<span class="sd">    uneven spacing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )</span>
<span class="sd">        The points defining the regular grid in n dimensions. The points in</span>
<span class="sd">        each dimension (i.e. every elements of the points tuple) must be</span>
<span class="sd">        strictly ascending or descending.</span>

<span class="sd">    values : array_like, shape (m1, ..., mn, ...)</span>
<span class="sd">        The data on the regular grid in n dimensions. Complex data can be</span>
<span class="sd">        acceptable.</span>

<span class="sd">    xi : ndarray of shape (..., ndim)</span>
<span class="sd">        The coordinates to sample the gridded data at</span>

<span class="sd">    method : str, optional</span>
<span class="sd">        The method of interpolation to perform. Supported are &quot;linear&quot;,</span>
<span class="sd">        &quot;nearest&quot;, &quot;slinear&quot;, &quot;cubic&quot;, &quot;quintic&quot;, &quot;pchip&quot;, and &quot;splinef2d&quot;.</span>
<span class="sd">        &quot;splinef2d&quot; is only supported for 2-dimensional data.</span>

<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, when interpolated values are requested outside of the</span>
<span class="sd">        domain of the input data, a ValueError is raised.</span>
<span class="sd">        If False, then `fill_value` is used.</span>

<span class="sd">    fill_value : number, optional</span>
<span class="sd">        If provided, the value to use for points outside of the</span>
<span class="sd">        interpolation domain. If None, values outside</span>
<span class="sd">        the domain are extrapolated.  Extrapolation is not supported by method</span>
<span class="sd">        &quot;splinef2d&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    values_x : ndarray, shape xi.shape[:-1] + values.shape[ndim:]</span>
<span class="sd">        Interpolated values at `xi`. See notes for behaviour when</span>
<span class="sd">        ``xi.ndim == 1``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 0.14</span>

<span class="sd">    In the case that ``xi.ndim == 1`` a new axis is inserted into</span>
<span class="sd">    the 0 position of the returned array, values_x, so its shape is</span>
<span class="sd">    instead ``(1,) + values.shape[ndim:]``.</span>

<span class="sd">    If the input data is such that input dimensions have incommensurate</span>
<span class="sd">    units and differ by many orders of magnitude, the interpolant may have</span>
<span class="sd">    numerical artifacts. Consider rescaling the data before interpolation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Evaluate a simple example function on the points of a regular 3-D grid:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import interpn</span>
<span class="sd">    &gt;&gt;&gt; def value_func_3d(x, y, z):</span>
<span class="sd">    ...     return 2 * x + 3 * y - z</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 4, 5)</span>
<span class="sd">    &gt;&gt;&gt; y = np.linspace(0, 5, 6)</span>
<span class="sd">    &gt;&gt;&gt; z = np.linspace(0, 6, 7)</span>
<span class="sd">    &gt;&gt;&gt; points = (x, y, z)</span>
<span class="sd">    &gt;&gt;&gt; values = value_func_3d(*np.meshgrid(*points, indexing=&#39;ij&#39;))</span>

<span class="sd">    Evaluate the interpolating function at a point</span>

<span class="sd">    &gt;&gt;&gt; point = np.array([2.21, 3.12, 1.15])</span>
<span class="sd">    &gt;&gt;&gt; print(interpn(points, values, point))</span>
<span class="sd">    [12.63]</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    NearestNDInterpolator : Nearest neighbor interpolation on unstructured</span>
<span class="sd">                            data in N dimensions</span>

<span class="sd">    LinearNDInterpolator : Piecewise linear interpolant on unstructured data</span>
<span class="sd">                           in N dimensions</span>

<span class="sd">    RegularGridInterpolator : interpolation on a regular or rectilinear grid</span>
<span class="sd">                              in arbitrary dimensions (`interpn` wraps this</span>
<span class="sd">                              class).</span>

<span class="sd">    RectBivariateSpline : Bivariate spline approximation over a rectangular mesh</span>

<span class="sd">    scipy.ndimage.map_coordinates : interpolation on grids with equal spacing</span>
<span class="sd">                                    (suitable for e.g., N-D image resampling)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sanity check &#39;method&#39; kwarg</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="s2">&quot;quintic&quot;</span><span class="p">,</span> <span class="s2">&quot;pchip&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;splinef2d&quot;</span><span class="p">,</span> <span class="s2">&quot;slinear&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interpn only understands the methods &#39;linear&#39;, &quot;</span>
                         <span class="s2">&quot;&#39;nearest&#39;, &#39;slinear&#39;, &#39;cubic&#39;, &#39;quintic&#39;, &#39;pchip&#39;, &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;and &#39;splinef2d&#39;. You provided </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;splinef2d&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The method splinef2d can only be used for &quot;</span>
                         <span class="s2">&quot;2-dimensional input data&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bounds_error</span> <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;splinef2d&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The method splinef2d does not support extrapolation.&quot;</span><span class="p">)</span>

    <span class="c1"># sanity check consistency of input dimensions</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">%d</span><span class="s2"> point arrays, but values has </span><span class="si">%d</span><span class="s2"> &quot;</span>
                         <span class="s2">&quot;dimensions&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="n">ndim</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndim</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;splinef2d&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The method splinef2d can only be used for &quot;</span>
                         <span class="s2">&quot;scalar data with one point per coordinate&quot;</span><span class="p">)</span>

    <span class="n">grid</span><span class="p">,</span> <span class="n">descending_dimensions</span> <span class="o">=</span> <span class="n">_check_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">_check_dimensionality</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="c1"># sanity check requested xi</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">_ndim_coords_from_arrays</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The requested sample points xi have dimension &quot;</span>
                         <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">, but this RegularGridInterpolator has &quot;</span>
                         <span class="s2">&quot;dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">bounds_error</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">),</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of the requested xi is out of bounds &quot;</span>
                                <span class="s2">&quot;in dimension </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1"># perform interpolation</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;slinear&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="s2">&quot;quintic&quot;</span><span class="p">,</span> <span class="s2">&quot;pchip&quot;</span><span class="p">]:</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                         <span class="n">bounds_error</span><span class="o">=</span><span class="n">bounds_error</span><span class="p">,</span>
                                         <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;splinef2d&quot;</span><span class="p">:</span>
        <span class="n">xi_shape</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># RectBivariateSpline doesn&#39;t support fill_value; we need to wrap here</span>
        <span class="n">idx_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">xi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># make a copy of values for RectBivariateSpline</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">values</span><span class="p">[:])</span>
        <span class="n">result</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">idx_valid</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fill_value</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xi_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Craig Yanitski.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>